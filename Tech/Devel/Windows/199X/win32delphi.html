<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<Html>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Generator" content="Microsoft Word 97">
   <meta name="subject" content="Win32, Delphi">
   <meta name="keywords" content="Win32, Delphi">
   <meta name="Template" content="C:\Program Files\Microsoft Office\Office\html.dot">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (X11; I; Linux 2.2.12-20 i586) [Netscape]">
   <title>Win32Del</title>
</head>
<body link="#0000FF" vlink="#800080">

<center><b><u><font face="Garamond"><font size=+1>Topics for Win32 &amp;
Delphi Training</font></font></u></b>
<p><b><font face="Garamond"><font size=-1>C.Hanish Menon</font></font></b>
<br><font size=-1>1998</font>
<br><b><font face="Garamond"><font size=-1>Status: INCOMPLETE</font></font></b></center>

<ul>
<li>
<b><font face="Garamond"><font color="#0000FF"><font size=+1>Differences
between C++ and Object Pascal</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Semantic</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Object Reference Model &amp; C++'s
lets say classic model</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Access Specifiers &amp; Classes</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Include &amp; Uses</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Constructors &amp; Destructors</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Virtual functions (Virtual/Dynamic
&amp; Override)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Multiple Inheritance</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Class Methods &amp; Class Data (Static
of C++).</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Operator Overloading</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font size=+1>Syntactic</font></font></b></li>
</ul>
</ul>

<ul>
<li>
<b><font face="Garamond"><font color="#0000FF"><font size=+1>OOPS as implemented
in Object Pascal</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Units &amp; Classes &amp; Friends</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Private, Protected, Public &amp;
Published</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Properties and Get &amp; Set Methods</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Single Rooted Hierarchy in Delphi</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Object Pascal &amp; Component Development</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Conversion (strict) &amp; Coercion
(variants)</font></font></b></li>
</ul>
</ul>

<ul>
<li>
<b><font face="Garamond"><font color="#0000FF"><font size=+1>Windows &amp;
Delphi</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>OS &amp; Computer
basics.</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>The 32 bit platform</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Processes &amp; Threads</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Message Handling</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Memory management</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Registering user defined Window
Classes &amp; Using PRE Registered Window Classes (Controls)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Owner &amp; Parent</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>TApplication</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>CreateHandle (The Window Class Registration
&amp; Creation)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Initialize (Misc. initializations
say OleAutomation)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>CreateForm</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Run (The Message Loop)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Default Exception Handling</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Help &amp; Hint management</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>ProcessMessage</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Handle, MainForm, Title, Exename,
Helpfile, Icon</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>Window Resources
&amp; Window Resources as Delphi Components or Properties</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>The Dialog Box</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Icons, Bitmaps as Properties of
Components.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>The DFM files</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>The Res files</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>ResourceString</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>Message handling</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Window Messages to Delphi Events</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Event->MainWndProc->WndProc->Dispatch->Handler</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>(check Dispatching Messages &amp;
the Message Handling system)</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>SubClassing
Window Controls</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>The Window's way</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>SetWindowLong</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>GetWindowLong</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Basing new Window Class on a Existing
Window Class</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font size=+1>The Delphi way</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>The WndProc (for Component Developers
to Override)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>The WindowProc property (for Temp
Subclassing)</font></font></b></li>
</ul>
</ul>

<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>Multitasking
&amp; Syncronization</font></font></font></b></li>

<dir>
<dir>
<ul>
<li>
<b><i><font face="Garamond"><font size=+1>Keeping track of too many threads
consumes CPU time; limit the number of threads per process on a Single
Processor system to 16</font></font></i></b></li>

<li>
<b><i><font face="Garamond"><font size=+1>With multiple threads updating
the same resources, keep threads synchronized to avoid conflicts</font></font></i></b></li>

<li>
<b><i><font face="Garamond"><font size=+1>Any methods that access a VCL
component and update a form must only be called from within the main VCL
thread</font></font></i></b></li>
</ul>
</dir>
</dir>

<ul>
<li>
<b><i>Window's way</i></b></li>

<ul>
<li>
<b><i>Processes &amp; Threads</i></b></li>

<ul>
<li>
<b><i>Private Address space |Share the Address Space &amp; Resources</i></b></li>
</ul>

<li>
<b><i>Scheduling (Prioritized Multiple Round robin Queues)</i></b></li>

<li>
<b><i>Base &amp; Dynamic Priorities</i></b></li>

<li>
<b><i>Using different Priority Classes.</i></b></li>

<li>
<b><i>CreateThread, ResumeThread, SuspendThread, SleepEx.</i></b></li>

<li>
<b><i>Synchronization (To avoid conflicts, it is necessary to synchronize
access by multiple threads to shared resources. Synchronization is also
necessary to ensure that interdependent code is executed in the proper
sequence.)</i></b></li>
</ul>
</ul>
</ul>
</ul>

<dir>
<dir>
<dir>
<dir>
<dir>
<dir>
<dir>
<dir>
<dir>
<dir><b><i>&middot; Synchronization objects: mutex, semaphore, and event
handles</i></b>
<p><b><i>&middot; Critical Section</i></b>
<p><b><i>&middot; File handles</i></b>
<p><b><i>&middot; Named pipe handles</i></b>
<p><b><i>&middot; Console input buffer handles</i></b>
<p><b><i>&middot; Communication device handles</i></b>
<p><b><i>&middot; Process handles</i></b>
<p><b><i>&middot; Thread handles</i></b>
<p><b><i>The WAIT .... Functions</i></b>
<p><b><i>Mutex &amp; Events can also be used for interprocess synchronization.</i></b>
<p><b><i>Createxxxx,Openxxx,Waitxxxx,Releasexxxx,SetEvent or ResetEvent
....</i></b></dir>
</dir>
</dir>
</dir>
</dir>
</dir>
</dir>
</dir>
</dir>
</dir>

<ul>
<dir>
<dir>
<dir>
<dir>
<ul>
<li>
<b><i>Thread Local Storage (TLS)</i></b></li>

<li>
<b><i>ExitThread, ExitProcess, TerminateThread, TerminateProcess, ThreadFunction
Returns</i></b></li>

<li>
<b><i>The alternatives Overlapped I/O &amp; Waiting on Multiple Events</i></b></li>
</ul>
</dir>
</dir>

<ul>
<li>
<b><i>Delphi way</i></b></li>

<ul>
<li>
<b><i>TThread</i></b></li>

<ul>
<li>
<b><i>Execute contains the code to execute.</i></b></li>

<li>
<b><i>Synchronize provides a mechanism for the passed class method to execute
as part of the main thread so a great way to allow code belonging to a
thread which accesses the VCL components to execute safely, thus avoiding
multithread Conflicts.</i></b></li>

<li>
<b><i>the very polite Terminate thread &amp; Terminated property over Win32
API's TerminateThread.</i></b></li>

<li>
<b><i>Suspend, Resume &amp; WaitFor.</i></b></li>
</ul>

<li>
<b><i>BeginThread &amp; EndThread instead of CreateThread &amp; ...</i></b></li>

<li>
<b><i>Synchronization objects include critical sections that temporarily
block the execution of other threads which may interfere with the successful
completion of a section of code, and event objects that allow threads to
signal when critical events have occurred.</i></b></li>

<ul>
<li>
<b><i>TEvent either within a single process or between processes.</i></b></li>

<li>
<b><i>TCriticalSection &amp; it's Enter(Acquire), Leave(Release)</i></b></li>
</ul>
</ul>
</ul>
</dir>
</dir>

<ul>
<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>Registry &amp;
Ini files</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>There use</font></font></b></li>
</ul>
</ul>
</ul>

<ul>
<li>
<b><font face="Garamond"><font color="#0000FF"><font size=+1>VCL of Delphi</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>Basic classes
like</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font color="#FF00FF"><font size=+1>TObject</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>The base of all classes</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>provides Object creation &amp; Deletion
support</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Create, Destroy(V), Free</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>NewInstance(V) &amp; FreeInstance(V)
( provide capabilities similar to New &amp; Delete in C++)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>If an exception escapes from a constructor,
the object's destructor will be called to clean up the failed instance.</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font size=+1>RTTI for Published properties &amp;
RTCI</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>ClassName, ClassParent, ClassInfo,
ClassType, InheritsFrom</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>InstanceSize, MethodAddress &amp;
MethodName, FieldAddress</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font size=+1>Message handling</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Dispatch (nV)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>DefaultHandler(V) (Called by Dispatch
when no message handler available for a particular message in the class)</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font size=+1>Basic Support for COM</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font color="#FF00FF"><font size=+1>TPersistent</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>DefineProperties (Streaming of Unpublished
Data)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Assign &amp; AssignTo (equivalent
to Copy Constructor of C++)</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Assign (copies the contents of the
passed object to itself)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>AssignTo (copies its contents to
the passed object) This is automatically called by the Assign statement
if it finds that the class doesn't know how to copy from the passed object.</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1><i>DestinationClassObject.Assign(SourceClassObject)
</i>in turn if required calls<i> SourceClassObject.AssignTo(DestinationClassObject)</i></font></font></b></li>

<li>
<b><i><font face="Garamond"><font size=+1>Useful when u want to assign
say the contents of the object of a class which u have written to the object
of a class which is already there in the VCL or is in someone else?s library.</font></font></i></b></li>

<li>
<b><i><font face="Garamond"><font size=+1>Override the AssignTo method
to extend the functionality of the Assign method of destination objects
so that they handle newly created object classes. When defining a new object
class, override the Assign method for every existing object class that
should be able to copy its properties to the new class. Override the AssignTo
method for every existing class that the new class can copy to (from Delphi
help)</font></font></i></b></li>
</ul>
</ul>
</ul>

<li>
<b><font face="Garamond"><font color="#FF00FF"><font size=+1>TComponent</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Used for Non Visual Components.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>to Appear in the Component Palette,
to be manipulated in the Form Designer</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>To Own other components &amp; manage
them</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Enhanced Streaming &amp; Filing
capabilities</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Basic COM capabilities &amp; ActiveX</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Methods that provide the above specified
functionality</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Loaded, Notification, ReadState,
WriteState</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>InsertComponent, DestroyComponents,
RemoveComponent</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Validatexxxx</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>ComponentState, ComponentStyle</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>IUnknown &amp; IDispatch</font></font></b></li>
</ul>
</ul>

<li>
<b><font face="Garamond"><font color="#FF00FF"><font size=+1>TControl</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>abstract base class to create Visual
Controls</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Controls are visual components,
meaning the user can see them and manipulate them at runtime. All controls
have properties, methods, and events in common that are specific to the
visual aspect of controls, such as the position of the control, the cursor
or hint associated with the control's window, methods to paint or move
the control, and events to respond to mouse actions. (from Delphi help)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Events are added to the VCL from
this point onwards, ca's WndProc implemented at this point. (check the
Window Message to Delphi Event topic above)</font></font></b></li>

<li>
<b><i><font face="Garamond"><font size=+1>DefaultHandler is the final opportunity
for component writers to handle messages to controls. The WndProc method
provides the first opportunity. Individual message methods such as Click
provide additional opportunities.</font></font></i></b></li>

<li>
<b><font face="Garamond"><font size=+1>Many times waiting for the Window
message queque &amp; loop to pass messages to a window or control's WindowProc
may be to slow in such cases call PERFORM method to bypass the Windows
message queue and send a message directly to the control's window procedure.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Call Repaint to force the control
to repaint its image immediately. If the ControlStyle property includes
csOpaque, the control paints itself directly. Otherwise, the Repaint method
calls the Invalidate method and then the Update method so that any visible
portions of controls beneath the control will be repainted as well.</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font color="#FF00FF"><font size=+1>TWinControl</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Abstract base class for all the
Windowed Controls</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>(from Delphi help)Windowed controls
are controls that</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Can receive focus while the application
is running.</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Other controls may display data,
but the user can use the keyboard to interact with a control only if the
control is a windowed control.</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font size=+1>Can contain other controls.</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>A control that contains other controls
is a parent. Only a windowed control can be a parent of one or more other
child controls.</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font size=+1>Have a window handle.</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>A window handle is the identifier
provided by Windows for a window. Windowed controls can represent standard
control windows provided by the Windows operating environment or custom
windows defined by the application.</font></font></b></li>
</ul>
</ul>

<li>
<b><font face="Garamond"><font size=+1>Newly created components are seldom
derived directly from TWinControl. Base most new controls on TCustomControl,
which provides a canvas and handles paint messages, or on any of several
more specialized controls, such as TButtonControl, TCustomComboBox, TCustomEdit,
or TCustomListBox.</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font color="#FF00FF"><font size=+1>TGraphicControl</font></font></font></b></li>

<ul>
<li>
<b><i><font face="Garamond"><font size=+1>These were very important in
Win16 where the Resources available with Windows OS where limited. But
in Win32 where the processes work in the Virtual address space, this is
not a major concern, but still for the type of many Custom Controls that
don't require a window handle it provides a very efficient implementation</font></font></i></b></li>

<li>
<b><i>(from Delphi help)The primary purpose of most graphic controls is
to display text or graphics. Delphi controls that descend from TGraphicControl
include TBevel, TImage, TPaintBox, TShape, TSpeedButton, TSplitter, and
TCustomLabel, from which TDBText and TLabel are derived.</i></b></li>

<li>
<b><i>In addition to everything inherited from the abstract TControl component,
TGraphicControl provides a Canvas property that provides ready access to
the control's drawing surface and a virtual Paint method called in response
to WM_PAINT messages received by a parent control.</i></b></li>

<li>
<b><i>Graphic controls cannot receive the input focus, nor can they contain
other controls. Because a graphic control doesn't need a Windows handle,
it's demand on system resources is lessened, and painting a graphic control
is quicker than painting a windowed control.</i></b></li>

<li>
<b><i>To create a control that can receive input focus or contain other
controls, but which needs a Canvas property and a Paint method, derive
a class from TCustomControl.</i></b></li>
</ul>

<li>
<b><font face="Garamond"><font color="#FF00FF"><font size=+1>TCustomControl</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>The abstract base for all custom
window controls that usually require a Canvas to display themselves or
some complex image</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Standard windowed controls already
"know" how to display themselves, because they are part of Windows. Thus,
a button or a check box component descends directly from TWinControl. When
creating original windowed controls that do not correspond to standard
Windows components, derive them from TCustomControl, rather than directly
from TWinControl. TCustomControl makes drawing original controls easier
by providing a Canvas property to manage the drawing surface and a virtual
Paint method that is called to respond to WM_PAINT messages.</font></font></b></li>

<li>
<b><i><font face="Garamond"><font size=+1>When creating custom controls
that don't need to receive input focus, derive them from TGraphicControl
instead of TCustomControl, to avoid the overhead associated with being
a windowed control. Painting a windowed control is slower than painting
a graphic control.</font></font></i></b></li>
</ul>
</ul>

<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>The CustomControl
Classes (TCustomxxxxx)</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>they act as abstract classes that
provide all the general functionality required for that group of Controls
as protected members, the individual implementations (i.e the derived Classes)
inturn have to decide and expose the members they require based on functionality
as public or published.</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>TCustomEdit, TCustomRichEdit,TCustomMemo</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>TCustomCheckBox, TCustomListBox,
TCustomComboBox</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>TCustomGroupBox, TCustomPanel, TCustomRadioGroup</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>TCustomGrid, TCustomDBGrid</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>TCustomForm</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>TCustomListView, TCustomTreeView,
TCustomUpDown, TCustomHotkey</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>TCustomStaticText</font></font></b></li>
</ul>
</ul>

<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>Screen object</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>A global variable of TScreen type
instanstiated automaticaly by delphi (rather in Forms unit). It gives the
current Screen state for that particular application</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>TScreen introduces properties that
keep track of</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>What forms and data modules have
been instantiated by the application.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>The active form, and the active
control within that form.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>The size and resolution of the screen.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>The cursors and fonts available
for the application to use.</font></font></b></li>
</ul>
</ul>

<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>Owner &amp;
Parent properties</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Owner takes care of freeing the
owned components when its being freed. This relates to the Delphi part
of the logic.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Parent is used to contain the children
within its client area. This relates to the Windows logic.</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>Exception</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Exception handling is the new way
of structured error handling in programs</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Object Pascal's exception handling
support allows the program logic to remain as it should and helps seperate
out the exception handling code.i.e it provides a structured means of separating
normal program logic from error handling logic, greatly increasing the
maintainability and robustness of applications.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>In Pascal or C we used to check
for the return value of functions or procedures to decide whether an exception
occured or not.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>But in Object pascal u have protected
blocks containing the code that as to be run normally. A Exception block
that will be executed in case of any exceptions &amp; a Finally block (the
CleanUp code) that will be always executed irrespective of whether an exception
occurs or not.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>If any error where to occur any
where an exception will be raised thus getting the control to the Exception
Handling block that follows the Protected Block. Here if that exception
is handled, the execution continues with the code after the Exception block.
However if an exception is not handled then automaticaly the block is unrolled
and the next outer block is checked for to see if the exception is handled,
This stack unrolling occurs till it gets handled some where, in the worst
case it goes to the Application's DefaultExceptionHandler.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>U have the Try Except &amp; the
Try Finally constructs to acheive this.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Exceptions are objects, So u can
raise any object instance as an exception. But the Standard exception handlers
only handle exception objects that belong to the Exception class or its
derivatives. So its better &amp; safer to derive custom exceptions from
the Exception class or its derivate.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>To Raise an exception when an error
occurs U create an instance of that Exception class and raise it. Later
when the exception gets handled, the <i>handler automatically frees that
instance</i>. (</font></font>internally: When an exception is raised, the
exception handling logic takes ownership of the exception object. Once
the exception is handled, the exception object is automatically destroyed
through a call to the object's Destroy destructor. An application should
never attempt to manually destroy a raised exception object)</b></li>

<li>
<b>In the Exception handler block use On [ExceptionInstanceTempVariable:]ExceptionClass
do ....;</b></li>

<li>
<b>One can reraise a exception in an exception handler by using just "Raise"</b></li>

<li>
<b>Resource protection block</b></li>
</ul>
</ul>
</ul>

<dir>
<dir>
<dir>
<dir>
<dir>
<dir>
<dir>
<dir><b>{ allocate the resource }</b>
<p><b>try</b>
<p><b>{ statements that use the resource }</b>
<p><b>finally</b>
<p><b>{ free the resource }</b>
<p><b>end;</b></dir>
</dir>
</dir>
</dir>
</dir>
</dir>
</dir>
</dir>

<ul>
<dir>
<dir>
<ul>
<li>
<b>We normally respond to an exception by either Cleaning Up things or
by Handling the exceptions or by both.</b></li>

<li>
<b>The SysUtils unit implements exception generation and handling for the
Object Pascal runtime library.</b></li>

<li>
<b>(from Delphi Help) Object Pascal uses objects to represent exceptions.
This has several advantages, the key ones of which are</b></li>

<ul>
<li>
<b>Exceptions can be grouped into hierarchies using inheritance</b></li>

<li>
<b>New exceptions can be introduced without affecting existing code</b></li>

<li>
<b>An exception object can carry information (such as an error message
or an error code) from the point where it was raised to the point where
it is handled</b></li>

<li>
<b>Using families (Exception Class Hierarchies) it is possible to handle
an entire group of exceptions under one name. For example, an exception
handler for EMathError will also handle EInvalidOp, EZeroDivide, EOverflow,
and EUnderflow exceptions, and any user-defined exceptions that directly
or indirectly derive from EMathError.</b></li>

<li>
<b>Exception classes sometimes define additional fields, methods, and properties
used to convey additional information about the exception</b></li>

<li>
<b>Raising an exception in the initialization code (see "The initialization
part") of a unit may not produce the desired behavior for the following
reason. Exception support comes from the SysUtils unit, so a unit, which
uses exceptions, must import SysUtils. With packages (see "Packages"),
the startup of a program has changed. An RTL helper function is called
to initialize all the units, but if an exception occurs during initialization,
all initialized units wll be finalized and the exception re-raised. In
this example, SysUtils will get initialized, then another unit raises the
exception and SysUtils gets finalized and the exception is re-raised. System
will catch the exception and since no exeption handler is installed, attempts
to handle it all by itself. It does not understand SysUtils based exceptions,
so it maps it to something else that it finds reasonable, usually the ctrl-c
interrupt.</b></li>

<li>
<b>To determine whether the exception block of a try...except statement
can handle a particular exception, the on...do exception handlers are examined
in order of appearance. The first exception handler that lists the exception
class or a base class of the exception is considered a match. If an exception
block contains an else part, and if none of the on...do exception handlers
match the exception, the else part is considered a match. An exception
block that contains only a statement list is considered a match for any
exception. (To locate a handler for a given exception class, the on...do
handlers are processed in order of appearance. This means that handlers
for the most derived classes should be listed first.)</b></li>

<li>
<b>As long as exceptions raised in an exception handler are also handled
within the exception handler, they do not affect the original exception.
However, once an exception raised in an exception handler propagates beyond
that handler, the original exception is lost.</b></li>

<li>
<b>If an exception is raised but not handled in the finally statement list,
that exception is propagated out of the try...finally statement, and any
original exception is lost. <i>(It is strongly recommended that a finally
statement list always handle all local exceptions, so as to not disturb
the propagation of an external exception.)</i></b></li>
</ul>
</ul>
</dir>
</dir>

<ul>
<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>TStream</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>An abstract class for all Delphi
Streams. One of the best methods for working with Memory &amp; Files.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>(from Delphi help)</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Use specialized stream objects to
read from, write to, or copy information stored in a particular medium.
Each descendant of TStream implements methods for transferring information
to and from a particular storage medium, such as a disk file, dynamic memory,
and so on. In addition to methods for reading, writing, and copying bytes
to and from the stream, stream objects permit applications to seek to an
arbitrary position in the stream. Properties of TStream provide information
about the stream, such as its size and the current position in the stream.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>TStream also introduces methods
that work in conjunction with components and filers for loading and saving
components in simple and inherited forms. These methods are called automatically
by global routines that initiate component streaming. They can also be
called directly to the initiate the streaming process. Note, however, that
component streaming always involves two additional objects:</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>A component object that is passed
as a parameter to the stream's methods.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>A filer object that is automatically
created by the stream, and associated with the stream.</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font size=+1>As an abstract class, TStream cannot
be instantiated. Descendant stream objects, such as memory and file streams
used for component streaming are created automatically by the global functions
ReadComponentRes and WriteComponentRes. For streaming other kinds of information,
choose a descendent class according to the specific data and storage needs.</font></font></b></li>
</ul>
</ul>
</ul>

<li>
<b><font face="Garamond"><font color="#0000FF"><font size=+1>Databases
in General</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>what is a DBMS</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Client/ Server architecture</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>RDBMS</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>SQL</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Domains</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Triggers</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Constraints</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>StoredProcs</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Generators</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Events</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Transactions</font></font></b></li>
</ul>
</ul>

<li>
<b><font face="Garamond"><font color="#0000FF"><font size=+1>Database access
in Delphi</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>The Layered
Approach (providing flexiblility to change any one layer without affecting
the others a lot)</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>Database Server (SQL or Flat file
Databases like DBase, Paradox, ...)</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>[ BDE (in turn Native Drivers (SQL
Links) or ODBC) ]</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>DataSet (BDE based on Independent
Dataset)</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>TDataset</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>TBDEDataset (TTable, TQuery, TStoredProc)</font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>BDEAliases provide a convinient
way of specifying the type of Database, its location, and associated parameters.
U can easily change over to another type of database or to another database
with out requiring to modify the BDE based applications usually.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>BDE allows one to access the Database
either as FlatTable or as a SQL Result set using TTable &amp; TQuery Components.
Of which TQuery is the flexible &amp; powerful one.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>TStoreproc is useful for working
with Servers that support Stored procedures at the server end.</font></font></b></li>
</ul>
</ul>

<li>
<b><font face="Garamond"><font size=+1>DataSource</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Data Aware Controls</font></font></b></li>
</ul>

<li>
<b><font face="Garamond"><font size=+1>TDatabase &amp; TSession</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Session Object</font></font></b></li>

<li>
<b><font face="Garamond"><font color="#FF0000"><font size=+1>Direct access
to InterBase (IB API)</font></font></font></b></li>
</ul>
</ul>

<ul>
<li>
<b><font face="Garamond"><font color="#0000FF"><font size=+1>COM &amp;
Delphi</font></font></font></b></li>
</ul>

<ul>
<li>
<b><font face="Garamond"><font color="#0000FF"><font size=+1>Version Control
Systems</font></font></font></b></li>
</ul>

<ul>
<li>
<b><font face="Garamond"><font color="#0000FF"><font size=+1>Delphi applications</font></font></font></b></li>

<ul>
<li>
<b><font face="Garamond"><font size=+1>General Application that shows the
use of Properties &amp; Events to interconnect different components and
get some job done.</font></font></b></li>

<li>
<b><font face="Garamond"><font size=+1>Database Application that introduces
the Layered approach to Database access in Delphi.</font></font></b></li>
</ul>
</ul>

</body>
</html>
